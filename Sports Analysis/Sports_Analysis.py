"""
Sports Analytics
"""

import numeric
import math
import codeskulptor
import urllib2
import comp140_module6 as sports

def read_matrix(filename):
    """
    Parse data at the input filename into a matrix.
    """
#   The following statement is used to make the filename into a URL
    number1=[]
    url=codeskulptor.file2url(filename)
    netfile=urllib2.urlopen(url)
#   The following stement is used to make the string gotten from the read 
#   line into the float numbers and then put the numbers into a sequence,
#   which will be later made into a matrix
    for line in netfile.readlines():
        number=line.split()
        for index in range(0,len(number)):
            number[index]=float(number[index].partition(",")[0])
        number1.append(number)
    return numeric.Matrix(number1)             
#print read_matrix("comp140_analytics_simple_matrix.txt")

def mse(result, expected):
    """
    Calculate the mean squared error between the sequences 
    result and expected.
    """
#   The following statement is directly copied from the solution 
#   of Markov Chain, which is used the formula to calculaete 
#   mean square error
    sum_squares = 0
    for num1, num2 in zip(result, expected):
        sum_squares += (num1 - num2) ** 2
    err = float(sum_squares) / len(expected)
    return err

class LinearModel:
    """
    A class used to represent a Linear statistical
    model of multiple variables. This model takes
    a vector of input variables and predicts that
    the measured variable will be their weighted sum.
    """

    def __init__(self, weights):
        """
        Create a new LinearModel.
        """
        self._weights = weights

    def __str__(self):
        """
        Return weights as a human readable string.
        """
        return str(self._weights)

    def get_weights(self):
        """
        Return the weights associated with the model.
        """
        return self._weights

    def generate_predictions(self, inputs):
        """
        Use this model to predict a matrix of
        measured variables given a matrix of input data.
        """
        return inputs*self.get_weights()

    def prediction_error(self, inputs, actual_result):
        """
        Calculate the MSE between the actual measured
        data and the predictions generated by this model
        based on the input data.
        """
        list1=[]
        list2=[]
        inputs1=self.generate_predictions(inputs)
        for index in range (0,inputs1.shape()[0]):
#  		In the following statement, list1 represents predictions data
# 		while list2 represents the actual data	
            list1.append(inputs1[(index,0)])
            list2.append(actual_result[(index,0)])
        return mse(list1, list2)

def fit_least_squares(input_data, output_data):
    """
    Create a Linear Model which predicts the output vector
    given the input matrix with minimal Mean-Squared Error.
    """
# 	The following statement is used to consider the special case
# 	, which is all elements in output_data is zero
    if output_data.abs().summation()==0:
        return LinearModel(input_data.transpose()*output_data)
    else:
# 	The following statement is used to calculate the weights without
#   using the inverse matrix of input_data because input_data doesn't 
#   have inverse matrix.
        x_transpose=input_data.transpose()
        product=x_transpose*input_data
        inverse=product.inverse()
        product2=x_transpose*output_data
        weights=inverse*product2
        return LinearModel(weights)
#print fit_least_squares(numeric.Matrix([[1.0, 2.0, 3.0], [4.0, 5.0, 6.0], [7.0, 8.0, 10.0]]), numeric.Matrix([[5.0], [1.0], [6.0]]))

def soft_threshold(parameter1, parameter2):
    """
    The follwing statement is used to move x closer to 0 by the distance t.
    In this way, it can better minimize MSE(w)+nameta||w||1
    """
    if parameter1>parameter2:
        return parameter1-parameter2
    elif math.sqrt(parameter1**2)<=parameter2:
        return 0
    elif (parameter1+parameter2)<0:
        return parameter1+parameter2
    
def fit_lasso(param, iterations, input_data, output_data):
    """
    Create a Linear Model which predicts the output vector
    given the input matrix such that:

    1) Mean-Squared error in predictions is small
    2) The weights vector is simple

    This is done using the LASSO method with lambda
    parameter param, calculated for the specified
    number of iterations.
    """
    weights=fit_least_squares(input_data, output_data).get_weights()
    counter=0                        
    while counter<iterations:
        weight1=weights.copy()
        for index in range (0,input_data.shape()[1]):
# 		The following statement is used to use matrix1 to represent XT*X
# 		and matrix2 to represent XT*y
            matrix1=input_data.transpose()*output_data
            matrix2=input_data.transpose()*input_data
            row=matrix2.getrow(index)
            matrix3=row*weights
            difference=matrix1[(index,0)]-matrix3[(0,0)]
#       Here a_quantity, b_quantity corresponds to aj, bj in the given recipe     
            a_quantity=difference/matrix2[(index,index)]
            b_quantity=param/(2*matrix2[(index,index)])
            weights[(index,0)]=soft_threshold(weights[(index,0)]+a_quantity,b_quantity )
        if (weights-weight1).abs().summation()<10**(-5):
            break   
        counter+=1  
    return LinearModel(weights)
#print fit_lasso(10, 2, numeric.Matrix([[1.0, 5.0], [2.0, 4.0]]), numeric.Matrix([[5.0], [20.0]]))
#obj=LinearModel(numeric.Matrix([[1.0], [5.0], [3.0]])) 
#obj.generate_predictions(numeric.Matrix([[1.0, 0.0, 0.0], [0.0, 1.0, 0.0], [0.0, 0.0, 1.0]])) 
def run_experiment(iterations):
    """
    Using some historical data from 1954-2000, as
    training data, generate weights for a Linear Model
    using both the Least-Squares method and the
    LASSO method (with several different lambda values).

    Test each of these models using the historical
    data from 2001-2012 as test data.
    """
#   The following statements are used to get prediction error based on the
# 	fit least square model for data from 1954-2000.
#   They are also used to print weights of the data
    matrix1=read_matrix("comp140_analytics_baseball.txt")
    actual_result1=read_matrix("comp140_analytics_wins.txt")
    weights1=fit_least_squares(matrix1,actual_result1)
    error1=weights1.prediction_error(matrix1,actual_result1)
    sports.print_weights(weights1) 
    
#   The following statements are used to get prediction error based on the
# 	fit LASSO model given lameda as 1000 for data from 1954-2000. They are
#   also used to print weights of the data
    error2=fit_lasso(1000,iterations,matrix1,actual_result1).prediction_error(matrix1,actual_result1)
    sports.print_weights(fit_lasso(1000,iterations,matrix1,actual_result1))
    
#   The following statements are used to get prediction error based on the
# 	fit LASSO model given lameda as 1001 for data from 1954-2000. 
#   They are also used to print weights of the data
    weights3=fit_lasso(1001,iterations,matrix1,actual_result1)
    error3=weights3.prediction_error(matrix1,actual_result1)
    sports.print_weights(weights3)
    
#   The following statements are used to get prediction error based on the
# 	fit LASSO model given lameda as 1002 for data from 1954-2000.
#   They are also used to print weights of the data
    weights4=fit_lasso(1002,iterations,matrix1,actual_result1)
    error4=weights4.prediction_error(matrix1,actual_result1)
    sports.print_weights(weights4)
    
#   The following statements are used to get prediction error based on the
# 	fit least square model for data from 2001-2012.
#   They are also used to print weights of the data    
    matrix11=read_matrix("comp140_analytics_baseball_test.txt")
    actual_result11=read_matrix("comp140_analytics_wins_test.txt")
    weights11=fit_least_squares(matrix11,actual_result11)
    error11=weights11.prediction_error(matrix11,actual_result11)
    sports.print_weights(weights11)
    
#   The following statements are used to get prediction error based on the
# 	fit LASSO model given lameda as 1000 for data from 2001-2012.
#   They are also used to print weights of the data    
    weights21=fit_lasso(1000,iterations,matrix11,actual_result11)
    error21=weights21.prediction_error(matrix11,actual_result11)
    sports.print_weights(weights21)
    
#   The following statements are used to get prediction error based on the
# 	fit LASSO model given lameda as 1001 for data from 2001-2012.
#   They are also used to print weights of the data       
    weights31=fit_lasso(1001,iterations,matrix11,actual_result11)
    error31=weights31.prediction_error(matrix11,actual_result11)
    sports.print_weights(weights31)
    
#   The following statements are used to get prediction error based on the
# 	fit LASSO model given lameda as 1002 for data from 2001-2012.
#   They are also used to print weights of the data        
    weights41=fit_lasso(1002,iterations,matrix11,actual_result11)
    error41=weights41.prediction_error(matrix11,actual_result11)
    sports.print_weights(weights41)
    
    print error1,error2, error3, error4
    print error11, error21, error31, error41


#When running the experiment, uncomment the following statements and change the desired
#iteration times inside the parentheses 
#run_experiment(1)
    
    
